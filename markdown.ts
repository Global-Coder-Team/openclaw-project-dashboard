import { writeFileSync, readFileSync, existsSync } from "node:fs";
import { join } from "node:path";
import type { QueueItem, Project } from "./db.js";

export function generateAgentQueueMd(params: {
  queueItems: QueueItem[];
  projects: Project[];
  recentlyCompleted: QueueItem[];
}): string {
  const lines: string[] = [];
  lines.push("# Agent Work Queue");
  lines.push(`> Auto-generated by Project Dashboard. Do not edit manually.`);
  lines.push(`> Last updated: ${new Date().toISOString()}`);
  lines.push("");

  // Priority Queue
  const pending = params.queueItems
    .filter((q) => q.status === "pending" || q.status === "in_progress")
    .sort((a, b) => a.rank - b.rank);

  if (pending.length) {
    lines.push("## Priority Queue");
    pending.forEach((q, i) => {
      const proj = q.projectId ? params.projects.find((p) => p.id === q.projectId) : null;
      const prefix = proj ? `[Project: ${proj.name}]` : "[Global]";
      const marker = q.status === "in_progress" ? " → IN PROGRESS" : "";
      lines.push(`${i + 1}. ${prefix} ${q.instruction}${marker}`);
    });
    lines.push("");
  }

  // Per-Project Standing Instructions
  const withInstructions = params.projects.filter(
    (p) => p.nextAction || p.strategy || p.constraints
  );

  if (withInstructions.length) {
    lines.push("## Per-Project Standing Instructions");
    for (const p of withInstructions) {
      lines.push(`### ${p.name}`);
      if (p.nextAction) lines.push(`- ${p.nextAction}`);
      if (p.strategy) lines.push(`- Strategy: ${p.strategy}`);
      if (p.constraints) lines.push(`- Constraints: ${p.constraints}`);
      lines.push("");
    }
  }

  // Recently Completed
  if (params.recentlyCompleted.length) {
    lines.push("## Recently Completed");
    for (const q of params.recentlyCompleted) {
      const proj = q.projectId ? params.projects.find((p) => p.id === q.projectId) : null;
      const prefix = proj ? `[${proj.name}]` : "[Global]";
      lines.push(`- ~~${prefix} ${q.instruction}~~ ✓`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

export function writeAgentQueueMd(workspaceDir: string, content: string): void {
  const filePath = join(workspaceDir, "AGENT_QUEUE.md");
  // Only write if content changed (ignoring timestamp line)
  const strip = (s: string) => s.replace(/^> Last updated:.*$/m, "");
  if (existsSync(filePath)) {
    const existing = readFileSync(filePath, "utf8");
    if (strip(existing) === strip(content)) return;
  }
  writeFileSync(filePath, content, "utf8");
}
